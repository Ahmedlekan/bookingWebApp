properties([
    parameters([ 
        string(  
            defaultValue: 'dev',  
            name: 'ENVIRONMENT', 
            description: 'Deployment environment (dev, staging, prod)' 
        ),
        choice(
            choices: ['plan', 'apply', 'destroy'], 
            name: 'TF_ACTION',
            description: 'Terraform action to perform'  
        ),
        booleanParam( 
            name: 'AUTO_APPROVE',  
            defaultValue: true,  
            description: 'Auto-approve Terraform actions' 
        )
    ]),
    buildDiscarder(logRotator(numToKeepStr: '10')),  // Keep only last 10 builds to save disk space
    disableConcurrentBuilds()  // Prevent multiple simultaneous runs to avoid Terraform state conflicts
])

pipeline {
    // agent {
    //     label 'terraform-aws'
    // }
    agent any

    environment {  // Set environment variables available throughout pipeline
        AWS_REGION = 'us-east-1'
        TF_DIR = 'EKS-Cluster-Tf/terraform'
        AWS_CREDS = 'aws-creds'
        TF_VERSION = '1.13.2' 
    }

    stages {  // Define the sequence of stages in the pipeline
        stage('Clean Workspace') {
            steps { 
                cleanWs()  // Clean the workspace to remove files from previous builds
                echo "Starting Terraform ${params.TF_ACTION} for ${params.ENVIRONMENT} environment" 
            }
        }

        stage('Git Checkout') {
            steps {
                git(  
                    branch: 'main',  // Branch to checkout
                    url: "https://github.com/Ahmedlekan/bookingWebApp.git", 
                    // credentialsId: 'github-creds',  // (for private repos)
                )
                sh 'git log -1 --oneline'  // Show the last commit information for traceability

                sh '''
                    echo "Current directory: $(pwd)"
                    echo "Listing EKS-Cluster-Tf contents:"
                    ls -la EKS-Cluster-Tf/
                    echo "Listing Terraform contents:"
                    ls -la EKS-Cluster-Tf/terraform/
                '''
            }
        }

        stage('Init') {
            steps {
                withAWS(credentials: 'aws-creds', region: 'us-east-1') {
                    sh 'terraform -chdir=EKS-Cluster-Tf/terraform/ init'
                }
            }
        }

        stage('Terraform Validate') {  // Validate Terraform configuration syntax
            steps {
                withAWS(credentials: "${AWS_CREDS}", region: "${AWS_REGION}") {
                    sh "terraform -chdir=${TF_DIR}/ validate" 
                }
            }
        }

        stage('Terraform Plan') { 
            when {  // Conditional execution: only run this stage if condition is met
                expression { params.TF_ACTION in ['plan', 'apply'] }  // Run for plan or apply actions
            }
            steps {
                withAWS(credentials: "${AWS_CREDS}", region: "${AWS_REGION}") {
                    sh """
                        terraform -chdir=${TF_DIR} plan -var-file=${params.ENVIRONMENT}.tfvars -out=tfplan.${params.ENVIRONMENT} -input=false
                    """
                    
                    // Save the plan file as a build artifact for review and audit
                    archiveArtifacts artifacts: "${TF_DIR}/tfplan.${params.ENVIRONMENT}", allowEmptyArchive: true
                }
            }
        }

        stage('Terraform Apply') {  // Apply Terraform changes
            when { 
                expression { params.TF_ACTION == 'apply' }  // Only run for apply action
            }
            steps {
                withAWS(credentials: "${AWS_CREDS}", region: "${AWS_REGION}") {
                    script {
                        def approveFlag = params.AUTO_APPROVE ? "-auto-approve" : ""  // Conditionally add auto-approve flag
                        // Apply changes using saved plan and Use the previously generated plan file
                        sh """
                            terraform -chdir=${TF_DIR} apply ${approveFlag} -input=false tfplan.${params.ENVIRONMENT}  
                        """
                    }
                }
            }
        }

        stage('Terraform Destroy') {  // Destroy infrastructure
            when { 
                expression { params.TF_ACTION == 'destroy' }  // Only run for destroy action
            }
            steps {
                script {
                    // Manual approval for destroy operations (safety mechanism)
                    if (params.AUTO_APPROVE) {  // Only ask for confirmation if auto-approve is enabled
                        input(  
                            id: 'confirm-destroy',  // Unique ID for this input step
                            message: "Are you sure you want to DESTROY ${params.ENVIRONMENT} environment?",
                            ok: 'Destroy' 
                        )
                    }
                    
                    withAWS(credentials: "${AWS_CREDS}", region: "${AWS_REGION}") {
                        def approveFlag = params.AUTO_APPROVE ? "-auto-approve" : ""  // Conditionally add auto-approve flag
                        // Destroy infrastructure, Load environment-specific variables and Non-interactive mode
                        sh """
                            terraform -chdir=${TF_DIR} destroy ${approveFlag} -var-file=${params.ENVIRONMENT}.tfvars -input=false 
                        """
                    }
                }
            }
        }

        stage('Update Kubeconfig') {  // Configure kubectl to access the new cluster
            when {  // Conditional execution
                expression { params.TF_ACTION == 'apply' }  // Only run after successful apply
            }
            steps {
                withAWS(credentials: "${AWS_CREDS}", region: "${AWS_REGION}") {
                    script {
                        // Extract cluster name from Terraform output
                        def clusterName = sh(
                            script: "terraform -chdir=${TF_DIR} output -raw cluster_name",  // Get raw output value
                            returnStdout: true  // Capture the output as string
                        ).trim()  // Remove any whitespace
                        
                        // Update kubeconfig to access the EKS cluster. 
                        // AWS CLI command to configure kubectl, AWS region and EKS cluster name
                        sh """
                            aws eks update-kubeconfig --region ${AWS_REGION} --name ${clusterName}
                        """
                        
                        // Test cluster access to verify configuration worked
                        sh "kubectl cluster-info"
                    }
                }
            }
        }
    }

    post { 
        always { 
            // Clean up plan files to avoid accumulating artifacts
            sh "rm -f ${TF_DIR}/tfplan.${params.ENVIRONMENT} || true"  // || true: don't fail if file doesn't exist
            
            // Send notifications or log summary
            script {
                def duration = currentBuild.durationString  // Get build duration
                def action = params.TF_ACTION.toUpperCase()  // Uppercase for readability
                def env = params.ENVIRONMENT.toUpperCase()  // Uppercase for readability
                
                echo "Terraform ${action} for ${env} completed in ${duration}"  // Summary message
            }
        }
        
        success { 
            echo "✅ Pipeline executed successfully!"
        }
        
        failure { 
            echo "❌ Pipeline failed!"
        }
        
        unstable { 
            echo "⚠️ Pipeline unstable!"
        }
    }
}